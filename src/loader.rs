use anyhow::{anyhow, Error};
use bevy::asset::{AssetLoader, LoadContext, LoadedAsset};
use bevy::pbr::StandardMaterial;
use block_mesh::QuadCoordinateConfig;

/// An asset loader capable of loading models in `.vox` files as usable [`bevy::render::mesh::Mesh`]es.
///
/// The meshes generated by this asset loader only use standard [`bevy::render::mesh::Mesh`] attributes for easier compatibility with shaders.
/// To get the `StandardMaterial` associated with a `.vox` file, append `#material` to the asset loading path.
/// You can load multiple models from the same `.vox` file by appending `#model{no}` to the asset loading path, where `{no}` corresponds to the model index in the file.
pub struct VoxLoader {
    /// Whether to flip the UVs vertically when meshing the models.
    /// You may want to change this to false if you aren't using Vulkan as a graphical backend for bevy , else this should default to true.
    pub(crate) config: QuadCoordinateConfig,
    pub(crate) v_flip_face: bool
}

impl AssetLoader for VoxLoader {
    fn load<'a>(
        &'a self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> bevy::utils::BoxedFuture<'a, Result<(), Error>> {
        Box::pin(async move {
            self.process_vox_file(bytes, load_context)?;
            Ok(())
        })
    }

    fn extensions(&self) -> &[&str] {
        &["vox"]
    }
}

impl VoxLoader {
    fn process_vox_file<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> Result<(), Error> {
        let file = match dot_vox::load_bytes(bytes) {
            Ok(data) => data,
            Err(error) => return Err(anyhow!(error)),
        };

        let palette: Vec<[u8; 4]> = file
            .palette
            .iter()
            .map(|color| color.to_le_bytes())
            .collect();
        let (palette_texture, palette_texture_width) = crate::mesh::palette_to_texture(&palette);
        let palette_texture_handle = load_context.set_labeled_asset(
            "base_color_texture",
            LoadedAsset::new(palette_texture)
        );

        load_context.set_labeled_asset("material", LoadedAsset::new(StandardMaterial {
            base_color_texture: Some(palette_texture_handle),
            ..StandardMaterial::default()
        }));

        for (index, model) in file.models.iter().enumerate() {
            let (shape, buffer) = crate::voxel::load_from_model(model);
            let mesh = crate::mesh::mesh_model(shape, &buffer, palette_texture_width, &self.config, self.v_flip_face);

            match index {
                0 => {
                    load_context.set_default_asset(LoadedAsset::new(mesh));
                }
                _ => {
                    load_context.set_labeled_asset(
                        &format!("model{}", index),
                        LoadedAsset::new(mesh),
                    );
                }
            }
        }

        Ok(())
    }
}
